Monorepo structure with zero boilerplate.

## Usage

1. Create a `packages` directory at the root of your repository.
2. Create a directory under `packages` for your new package.
3. Create an `index.ts` file in the package directory. This is the main file of your package and you should export your package's exports from here.
4. To import from other packages in the monorepo, use `import ... from '$package-name'` where `package-name` is the name of the package directory.
5. Initialize a `package.json` file at the root of your repository.
6. Install `@jakzo/monorepo` as a dev dependency.
7. Create an npm script in your package.json which runs `monorepo publish`.

## Why?

There are many other monorepo tools out there (Lerna, Bolt, Rush, etc.) but this tool fills a gap that they don't:

- **They are not very opinionated** - They allow you to set up your packages and monorepo in many different ways. While this is helpful for some, it is not necessary for most. Tools which are super configurable tend to have a steep learning curve and scare off new users.
- **Configuring tooling for monorepos is hard** - Setting up a nice dev loop for a monorepo can be challenging when using tools not fully designed for the monorepo use-case. One example is Typescript. In a Lerna monorepo you could have two Typescript packages - the first depending on the second. Using project references you could have the dependency also be built when building the first, but if you ever transitively export a type from another package in your monorepo (happens frequently) there will be errors. Going to reference in an IDE also opens the built file instead of the source, even though it's in the same repo. This is solved by making the code look like a regular repo and splitting the built files into separate packages at publish time.
- **They require writing boilerplate** - Whenever you create a new package with these tools you need to write a new package.json, tsconfig, etc. These are also prone to getting out-of-sync between packages. For example, you may bump the version of node in the `engines` field in a package.json but forget to do it in another. You can write tools to automate this but checking in files generated by tools is an antipattern because users may inadvertantly modify the generated files (eg. updating the `engines` field of a package.json only to have it overwritten later by the tool). Also writing boilerplate is a waste of time and it clutters your code.
